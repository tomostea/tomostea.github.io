<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0">
  <title>ğŸ”</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/codemirror.min.js"
    integrity="sha512-3S64QagKiTlNjSfuh3UYtYSkP494WHoWc96YvbmB2BReHpNtxlrMNY6MbJLDpavcgD8Pj5p44F/PY586uVO5iA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/codemirror.min.css"
    integrity="sha512-uf06llspW44/LZpHzHT6qBOIVODjWtv4MxCricRxkzvopAlSWnTf6hpZTFxuuZcuNE9CBQhqE0Seu1CoRk84nQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/mode/javascript/javascript.min.js"
    integrity="sha512-I6CdJdruzGtvDyvdO4YsiAq+pkWf2efgd1ZUSK2FnM/u2VuRASPC7GowWQrWyjxCZn6CT89s3ddGI+be0Ak9Fg=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/mode/markdown/markdown.min.js"
    integrity="sha512-DmMao0nRIbyDjbaHc8fNd3kxGsZj9PCU6Iu/CeidLQT9Py8nYVA5n0PqXYmvqNdU+lCiTHOM/4E7bM/G8BttJg=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/mode/xml/xml.min.js"
    integrity="sha512-LarNmzVokUmcA7aUDtqZ6oTS+YXmUKzpGdm8DxC46A6AHu+PQiYCUlwEGWidjVYMo/QXZMFMIadZtrkfApYp/g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/search/search.min.js"
    integrity="sha512-Mw3RqCUHTyvN3iSp5TSs731TiLqnKrxzyy2UVZv3+tJa524Rj7pBC7Ivv3ka2oDnkQwLOMHNDKU5nMJ16YRgrA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/search/searchcursor.min.js"
    integrity="sha512-+ZfZDC9gi1y9Xoxi9UUsSp+5k+AcFE0TRNjI0pfaAHQ7VZTaaoEpBZp9q9OvHdSomOze/7s5w27rcsYpT6xU6g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
  <textarea id="text_id"></textarea>
  <label>ğŸ“‚<input type="file" id="db_open" onchange="readFile('#db_open', '#db_filename')"
      style="display:none;" /></label>
  <input id="db_filename" placeholder="a.md" size="4" />
  <a onclick="saveFile(document.querySelector('#db_filename').value, '#db_save')" id="db_save">ğŸ’¾</a>
  <select id="lang_mode" onchange="changeMode('#lang_mode')">
    <option value="markdown">md</option>
    <option value="javascript">js</option>
  </select>
  <button onclick="doCode()">ğŸ’»</button>
  <input id="password" type="password" size="1">
  <button onclick="doAES('#text_id', '#password', '#text_id')">ğŸ”‘</button>
  <button onclick="goToTop()">â«</button>
  <button onclick="goToBottom()">â¬</button>
  <br>
  <button onclick="doUndo()">ğŸ”™</button>
  <button onclick="doRedo()">ğŸ”œ</button>
  <button onclick="findPrev()">â¬…ï¸</button>
  <button onclick="findText()">ğŸ”</button>
  <button onclick="findNext()">â¡ï¸</button>
  <button onclick="replaceText()">âœï¸</button>
  <button onclick="replaceAll()">ğŸ–‹</button>
  <script>
    const myTextArea = document.querySelector("#text_id")
    const myCodeMirror = CodeMirror.fromTextArea(myTextArea, { lineNumbers: true, lineWrapping: true, mode: "markdown" });
    myCodeMirror.setSize(360, 600);
    function saveFile(filename, saveid, filedata = myCodeMirror.doc.getValue()) {
      const saveA = document.querySelector(saveid);
      const blob = new Blob([filedata]);
      saveA.href = URL.createObjectURL(blob);
      saveA.download = filename;
    };
    async function readFile(openid, filenameid = "", mime = "plain/text") {
      const file = document.querySelector(openid).files[0];
      const readed = await readFileAsync(file, mime);
      const filenameBox = document.querySelector(filenameid);
      myCodeMirror.doc.setValue(readed.result);
      filenameBox.value = file.name
      return [readed.result, file.name]
    }
    function readFileAsync(file, mime) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        mime == "plain/text" ? reader.readAsText(file) : reader.readAsArrayBuffer(file);
        reader.onload = () => resolve(reader); // ã‚¤ãƒ™ãƒ³ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«é–¢æ•°ã‚’è¨­å®šã™ã‚‹ã¨ã€ãã®ã‚¤ãƒ™ãƒ³ãƒˆãŒèµ·ããŸéš›ã«é–¢æ•°ãŒå®Ÿè¡Œã•ã‚Œã‚‹
        reader.onerror = () => reject(reader); // [ã€JavaScriptå…¥é–€ã€‘åˆå¿ƒè€…ã§ã‚‚åˆ†ã‹ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ã®ä½œã‚Šæ–¹ã¾ã¨ã‚ï¼ | ä¾ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢å¡¾ãƒ–ãƒ­ã‚°ï¼ˆSamurai Blogï¼‰ - ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°å…¥é–€è€…å‘ã‘ã‚µã‚¤ãƒˆ](https://www.sejuku.net/blog/61631)
      })
    }
    function findText() {
      myCodeMirror.execCommand("find")
    }
    function findNext() {
      myCodeMirror.execCommand("findNext")
    }
    function findPrev() {
      myCodeMirror.execCommand("findPrev")
    }
    function replaceText() {
      myCodeMirror.execCommand("replace")
    }
    function replaceAll() {
      myCodeMirror.execCommand("replaceAll")
    }
    function doUndo() {
      myCodeMirror.execCommand("undo")
    }
    function doRedo() {
      myCodeMirror.execCommand("redo")
    }
    function goToTop() {
      myCodeMirror.execCommand("goDocStart")
    }
    function goToBottom() {
      myCodeMirror.execCommand("goDocEnd")
    }
    function changeMode(modeId) {
      const mode = document.querySelector(modeId).value
      myCodeMirror.setOption("mode", mode)
    }
    function doCode(fileData = myCodeMirror.doc.getValue()) {
      eval(fileData)
    }


    // [AES Bookmarklet](https://gist.github.com/guelfoweb/426d2813e3c8278ce74d)
    function doAES(inputElm, passwordElm, outputElm) {
      function Cipher(input, w) {
        var Nb = 4;
        var Nr = w.length / Nb - 1;
        var state = [
          [],
          [],
          [],
          []
        ];
        for (var i = 0; i < 4 * Nb; i++) state[i % 4][Math.floor(i / 4)] = input[i];
        state = AddRoundKey(state, w, 0, Nb);
        for (var round = 1; round < Nr; round++) {
          state = SubBytes(state, Nb);
          state = ShiftRows(state, Nb);
          state = MixColumns(state, Nb);
          state = AddRoundKey(state, w, round, Nb);
        }
        state = SubBytes(state, Nb);
        state = ShiftRows(state, Nb);
        state = AddRoundKey(state, w, Nr, Nb);
        var output = new Array(4 * Nb);
        for (var i = 0; i < 4 * Nb; i++) output[i] = state[i % 4][Math.floor(i / 4)];
        return output;
      }

      function SubBytes(s, Nb) {
        for (var r = 0; r < 4; r++) {
          for (var c = 0; c < Nb; c++) s[r][c] = Sbox[s[r][c]];
        }
        return s;
      }

      function ShiftRows(s, Nb) {
        var t = new Array(4);
        for (var r = 1; r < 4; r++) {
          for (var c = 0; c < 4; c++) t[c] = s[r][(c + r) % Nb];
          for (var c = 0; c < 4; c++) s[r][c] = t[c];
        }
        return s;
      }

      function MixColumns(s, Nb) {
        for (var c = 0; c < 4; c++) {
          var a = new Array(4);
          var b = new Array(4);
          for (var i = 0; i < 4; i++) {
            a[i] = s[i][c];
            b[i] = s[i][c] & 0x80 ? s[i][c] << 1 ^ 0x011b : s[i][c] << 1;
          }
          s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3];
          s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3];
          s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3];
          s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3];
        }
        return s;
      }

      function AddRoundKey(state, w, rnd, Nb) {
        for (var r = 0; r < 4; r++) {
          for (var c = 0; c < Nb; c++) state[r][c] ^= w[rnd * 4 + c][r];
        }
        return state;
      }

      function KeyExpansion(key) {
        var Nb = 4;
        var Nk = key.length / 4;
        var Nr = Nk + 6;
        var w = new Array(Nb * (Nr + 1));
        var temp = new Array(4);
        for (var i = 0; i < Nk; i++) {
          var r = [key[4 * i], key[4 * i + 1], key[4 * i + 2], key[4 * i + 3]];
          w[i] = r;
        }
        for (var i = Nk; i < (Nb * (Nr + 1)); i++) {
          w[i] = new Array(4);
          for (var t = 0; t < 4; t++) temp[t] = w[i - 1][t];
          if (i % Nk == 0) {
            temp = SubWord(RotWord(temp));
            for (var t = 0; t < 4; t++) temp[t] ^= Rcon[i / Nk][t];
          } else if (Nk > 6 && i % Nk == 4) {
            temp = SubWord(temp);
          }
          for (var t = 0; t < 4; t++) w[i][t] = w[i - Nk][t] ^ temp[t];
        }
        return w;
      }

      function SubWord(w) {
        for (var i = 0; i < 4; i++) w[i] = Sbox[w[i]];
        return w;
      }

      function RotWord(w) {
        var tmp = w[0];
        for (var i = 0; i < 3; i++) w[i] = w[i + 1];
        w[3] = tmp;
        return w;
      }
      var Sbox = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
      var Rcon = [
        [0x00, 0x00, 0x00, 0x00],
        [0x01, 0x00, 0x00, 0x00],
        [0x02, 0x00, 0x00, 0x00],
        [0x04, 0x00, 0x00, 0x00],
        [0x08, 0x00, 0x00, 0x00],
        [0x10, 0x00, 0x00, 0x00],
        [0x20, 0x00, 0x00, 0x00],
        [0x40, 0x00, 0x00, 0x00],
        [0x80, 0x00, 0x00, 0x00],
        [0x1b, 0x00, 0x00, 0x00],
        [0x36, 0x00, 0x00, 0x00]
      ];

      function AESEncryptCtr(plaintext, password, nBits) {
        var blockSize = 16;
        if (!(nBits == 128 || nBits == 192 || nBits == 256)) return '';
        plaintext = plaintext.encodeUTF8();
        password = password.encodeUTF8();
        var nBytes = nBits / 8;
        var pwBytes = new Array(nBytes);
        for (var i = 0; i < nBytes; i++) {
          pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
        }
        var key = Cipher(pwBytes, KeyExpansion(pwBytes));
        key = key.concat(key.slice(0, nBytes - 16));
        var counterBlock = new Array(blockSize);
        var nonce = (new Date()).getTime();
        var nonceSec = Math.floor(nonce / 1000);
        var nonceMs = nonce % 1000;
        for (var i = 0; i < 4; i++) counterBlock[i] = (nonceSec >>> i * 8) & 0xff;
        for (var i = 0; i < 4; i++) counterBlock[i + 4] = nonceMs & 0xff;
        var ctrTxt = '';
        for (var i = 0; i < 8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);
        var keySchedule = KeyExpansion(key);
        var blockCount = Math.ceil(plaintext.length / blockSize);
        var ciphertxt = new Array(blockCount);
        for (var b = 0; b < blockCount; b++) {
          for (var c = 0; c < 4; c++) counterBlock[15 - c] = (b >>> c * 8) & 0xff;
          for (var c = 0; c < 4; c++) counterBlock[15 - c - 4] = (b / 0x100000000 >>> c * 8);
          var cipherCntr = Cipher(counterBlock, keySchedule);
          var blockLength = b < blockCount - 1 ? blockSize : (plaintext.length - 1) % blockSize + 1;
          var cipherChar = new Array(blockLength);
          for (var i = 0; i < blockLength; i++) {
            cipherChar[i] = cipherCntr[i] ^ plaintext.charCodeAt(b * blockSize + i);
            cipherChar[i] = String.fromCharCode(cipherChar[i]);
          }
          ciphertxt[b] = cipherChar.join('');
        }
        var ciphertext = ctrTxt + ciphertxt.join('');
        ciphertext = ciphertext.encodeBase64();
        return ciphertext;
      }

      function AESDecryptCtr(ciphertext, password, nBits) {
        var blockSize = 16;
        if (!(nBits == 128 || nBits == 192 || nBits == 256)) return '';
        ciphertext = ciphertext.decodeBase64();
        password = password.encodeUTF8();
        var nBytes = nBits / 8;
        var pwBytes = new Array(nBytes);
        for (var i = 0; i < nBytes; i++) {
          pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
        }
        var key = Cipher(pwBytes, KeyExpansion(pwBytes));
        key = key.concat(key.slice(0, nBytes - 16));
        var counterBlock = new Array(8);
        ctrTxt = ciphertext.slice(0, 8);
        for (var i = 0; i < 8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);
        var keySchedule = KeyExpansion(key);
        var nBlocks = Math.ceil((ciphertext.length - 8) / blockSize);
        var ct = new Array(nBlocks);
        for (var b = 0; b < nBlocks; b++) ct[b] = ciphertext.slice(8 + b * blockSize, 8 + b * blockSize + blockSize);
        ciphertext = ct;
        var plaintxt = new Array(ciphertext.length);
        for (var b = 0; b < nBlocks; b++) {
          for (var c = 0; c < 4; c++) counterBlock[15 - c] = ((b) >>> c * 8) & 0xff;
          for (var c = 0; c < 4; c++) counterBlock[15 - c - 4] = (((b + 1) / 0x100000000 - 1) >>> c * 8) & 0xff;
          var cipherCntr = Cipher(counterBlock, keySchedule);
          var plaintxtByte = new Array(ciphertext[b].length);
          for (var i = 0; i < ciphertext[b].length; i++) {
            plaintxtByte[i] = cipherCntr[i] ^ ciphertext[b].charCodeAt(i);
            plaintxtByte[i] = String.fromCharCode(plaintxtByte[i]);
          }
          plaintxt[b] = plaintxtByte.join('');
        }
        var plaintext = plaintxt.join('');
        plaintext = plaintext.decodeUTF8();
        return plaintext;
      }
      var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
      String.prototype.encodeBase64 = function (utf8encode) {
        utf8encode = (typeof utf8encode == 'undefined') ? false : utf8encode;
        var o1, o2, o3, bits, h1, h2, h3, h4, e = [],
          pad = '',
          c, plain, coded;
        plain = utf8encode ? this.encodeUTF8() : this;
        c = plain.length % 3;
        if (c > 0) {
          while (c++ < 3) {
            pad += '=';
            plain += '\0';
          }
        }
        for (c = 0; c < plain.length; c += 3) {
          o1 = plain.charCodeAt(c);
          o2 = plain.charCodeAt(c + 1);
          o3 = plain.charCodeAt(c + 2);
          bits = o1 << 16 | o2 << 8 | o3;
          h1 = bits >> 18 & 0x3f;
          h2 = bits >> 12 & 0x3f;
          h3 = bits >> 6 & 0x3f;
          h4 = bits & 0x3f;
          e[c / 3] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
        }
        coded = e.join('');
        coded = coded.slice(0, coded.length - pad.length) + pad;
        return coded;
      };
      String.prototype.decodeBase64 = function (utf8decode) {
        utf8decode = (typeof utf8decode == 'undefined') ? false : utf8decode;
        var o1, o2, o3, h1, h2, h3, h4, bits, d = [],
          plain, coded;
        coded = utf8decode ? this.decodeUTF8() : this;
        for (var c = 0; c < coded.length; c += 4) {
          h1 = b64.indexOf(coded.charAt(c));
          h2 = b64.indexOf(coded.charAt(c + 1));
          h3 = b64.indexOf(coded.charAt(c + 2));
          h4 = b64.indexOf(coded.charAt(c + 3));
          bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;
          o1 = bits >>> 16 & 0xff;
          o2 = bits >>> 8 & 0xff;
          o3 = bits & 0xff;
          d[c / 4] = String.fromCharCode(o1, o2, o3);
          if (h4 == 0x40) d[c / 4] = String.fromCharCode(o1, o2);
          if (h3 == 0x40) d[c / 4] = String.fromCharCode(o1);
        }
        plain = d.join('');
        return utf8decode ? plain.decodeUTF8() : plain;
      };
      String.prototype.encodeUTF8 = function () {
        var str = this.replace(/[\u0080-\u07ff]/g, function (c) {
          var cc = c.charCodeAt(0);
          return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);
        });
        str = str.replace(/[\u0800-\uffff]/g, function (c) {
          var cc = c.charCodeAt(0);
          return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);
        });
        return str;
      };
      String.prototype.decodeUTF8 = function () {
        var str = this.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function (c) {
          var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
          return String.fromCharCode(cc);
        });
        str = str.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (c) {
          var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
          return String.fromCharCode(cc);
        });
        return str;
      };
      var text = window.getSelection ? window.getSelection().toString() : document.selection.createRange().text;
      if (!text) {
        text = myCodeMirror.doc.getValue();
      }
      if (!text) {
        return;
      }
      var pass = document.querySelector(passwordElm).value;
      if (pass) {
        var tag = /\[aesbookmarklet\](.*)\[\/aesbookmarklet\]/;
        if (tag.test(text)) {
          var matches = tag.exec(text);
          text = matches[1];
          dec = AESDecryptCtr(text, pass, 256);
          myCodeMirror.doc.setValue(dec)
        } else {
          enc = AESEncryptCtr(text, pass, 256);
          myCodeMirror.doc.setValue('\[aesbookmarklet\]' + enc + '\[/aesbookmarklet\]');
        }
      }
    }
  </script>
</body>

</html>
